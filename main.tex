%%%%%%%%%%%%%%%%%%%%%%% file template.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is a template file for Web of Conferences Journal
%
% Copy it to a new file with a new name and use it as the basis
% for your article
%
%%%%%%%%%%%%%%%%%%%%%%%%%% EDP Science %%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%\documentclass[option]{webofc}
%%% "twocolumn" for typesetting an article in two columns format (default one column)

\documentclass{webofc}
\usepackage[varg]{txfonts}   % Web of Conferences font
\usepackage{natbib}

%%% for the arXiv, be sure to include _minted-main/
% \usepackage[draft]{minted}
\usepackage{minted}

\begin{document}

\title{AwkwardForth: accelerating Uproot with an internal DSL}
% \subtitle{HERE}

\author{\firstname{Jim} \lastname{Pivarski}\inst{1}\fnsep\thanks{\email{pivarski@princeton.edu}} \and
        \firstname{Ianna} \lastname{Osborne}\inst{1}\fnsep\thanks{\email{ianna.osborne@cern.ch}} \and
        \firstname{Pratyush} \lastname{Das}\inst{2}\fnsep\thanks{\email{reikdas@gmail.com}} \and
        \firstname{David} \lastname{Lange}\inst{1}\fnsep\thanks{\email{david.lange@cern.ch}} \and
        \firstname{Peter} \lastname{Elmer}\inst{1}\fnsep\thanks{\email{peter.elmer@cern.ch}}}

\institute{Princeton University, Princeton, New Jersey, United States. \and Institute of Engineering and Management, Kolkata, West Bengal, India.}

\abstract{
  Insert your english abstract here.
}

\maketitle

\section{Motivation}

Despite being written in Python, Uproot~\cite{uproot} can read simple data types from ROOT~\cite{root} files as fast as any compiled code because these values are already contiguous in the raw bytes of the file. No computations are required to get a ROOT TBasket of numerical data from disk into memory, as an array, except to swap endianness if little-endian arrays are desired. Python's NumPy~\cite{numpy} library casts data from raw bytes as a metadata-only operation, and performs operations that scale as $\mathcal{O}(n)$, where $n$ is the length of the array, in precompiled code.

For more complex data types, however, the cost of computing in Python increases. Variable-length (``jagged'') arrays are still relatively quick, since the ROOT format separates the numerical content of these arrays from the integers that define the starting positions of each entry's array. This is nearly the format required by Awkward Array~\cite{awkward}, and only requires minor transformations, like subtracting the TBasket header from the byte offsets and dividing them by the number of bytes per entry. Objects with fixed-size headers and consisting of fixed-size fields, such as \mintinline{c++}{std::vector<TLorentzVector>}, can be extracted using NumPy tricks, though these tricks require more intermediate arrays, further slowing the transformation. Finally, general objects with nested, variable-length data, the simplest of which is \mintinline{c++}{std::vector<std::vector<float>>}, require custom loops over the data. In Python, this is hundreds of times slower than C++.

Previously, we quantified this slow-down~\cite{chep2019} using ROOT files containing \mintinline{c++}{float}, \mintinline{c++}{std::vector<float>}, and vectors of vectors up to three levels deep, reading them with the then-current Python codebase and with custom C++ code, which represents what is possible now that Awkward Array is implemented in C++. The read performance of \mintinline{c++}{float} data is identical for Python and C++, the C++ is several times faster for \mintinline{c++}{std::vector<float>}, and the gap widens to factors of hundreds for the doubly-nested and triply-nested cases. Leveraging Awkward Array's C++ layer to accelerate Uproot is a worthwhile goal.

However, unless we limit our attention to special cases like nested vectors of numbers, this deserialization code is not known at compile-time. The byte-for-byte layout of a complex data type is expressed as data, in the TStreamerInfo of a ROOT file, and is therefore discovered at runtime. Moreover, the specifics of ROOT deserialization should not be spread between two packages, Uproot and Awkward Array: Uproot should focus entirely on ROOT I/O as Awkward Array focuses on array manipulation. The problem is to satisfy three constraints:
\begin{enumerate}
\item Deserialization code must run as fast (or nearly as fast) as compiled code.
\item This code must be generated at runtime from TStreamerInfo.
\item All ``knowledge'' of ROOT I/O must be in Uproot, not Awkward Array.
\end{enumerate}

The first two constraints could be satisfied by just-in-time (JIT) compilation. This is, in fact, what ROOT's Cling compiler does. The third constraint could be satisfied by adding a C++ layer to Uproot. Both of these solutions, however, would significantly complicate the dependencies of Uproot or Awkward Array, and Uproot's portability is often cited as its best feature. The issue is not the disk space required to download a JIT compiler, but the likelihood of failure---complex software doesn't install as easily as it should in all environments.

This paper describes a different solution to the constraints listed above, which does not affect the portability of Uproot or Awkward Array. We introduce AwkwardForth, a domain-specific language (DSL) for deserializing arbitrary data into Awkward Arrays that is runtime-interpreted but nearly as fast as compiled code. Unlike DSLs intended for humans to read and write, this DSL is ``internal,'' only used to communicate between software packages. Uproot's task becomes one of expressing ROOT I/O logic in AwkwardForth and Awkward Array executes it, returning filled arrays.

\section{AwkwardForth}

AwkwardForth is a member of the Forth family of languages, which includes Postscript, another internal DSL. AwkwardForth adheres to a subset of the ANSI Forth Standard~\cite{forth-standard} and has extensions for interpreting arbitrary input buffers and filling columns for Awkward Array.

Like all Forths, AwkwardForth is primarily concerned with stack manipulation. The runtime environment features a stack of integers and programs define ``words'' that manipulate the stack (as well as input and output buffers, in the case of AwkwardForth). Each word consumes and produces an arbitrary number of arguments and return values through this stack, and hence Forth words are more general than functions in a typical programming language. Whereas functional programming languages eliminate or minimize side-effects, Forth acts exclusively through side-effects. As such, it is more like an extensible assembly language.

The popularity of Forth peaked in the early 1980's because its interactive interpreter could fit within the tight resource constraints of early personal computers~\cite{forth}. This same interactive minimalism makes it an ideal candidate for running fast programs that must be generated at runtime, such as deserializing ROOT files. On typical hardware, AwkwardForth takes about 5~ns to evaluate each word, compared to about 900~ns for Python to evaluate a bytecode.

Though motivated by the problem of ROOT deserialization, AwkwardForth is intended for the general problem of deserializing non-columnar data formats into columnar Awkward Arrays. Many file formats, such as ProtoBuf, Thrift, Avro, FlatBuffers, JSON, and BSON, describe data structures in a record-oriented layout, with all fields of one record contiguous with each other, while columnar formats like Parquet, Arrow, and Awkward Array place all values of one field contiguous with each other before moving on to the next field. Conversions between columnar formats can be very fast, sometimes casting, rather than copying, the columns. Record-oriented formats, on the other hand, must be fully parsed. In this paper, we examine AwkwardForth's deserialization performance for ROOT, Avro, and Parquet.

Awkward Array has a tool for converting arbitrary record-oriented data into Awkward Arrays: \mintinline{c++}{ArrayBuilder} constructs arrays in an append-only order, driven by commands such as \mintinline{c++}{begin_record}/\mintinline{c++}{end_record}, switch to \mintinline{c++}{field}, \mintinline{c++}{integer}, and \mintinline{c++}{begin_list}/\mintinline{c++}{end_list}. A consequence of this generality is that \mintinline{c++}{ArrayBuilder} discovers the array's data type at runtime, adding output buffers as the observed type gets more complex. While this is great for JSON, type discovery is unnecessarily slow for formats whose type is known in advance, though perhaps not at compile-time. (Uproot currently uses \mintinline{c++}{ArrayBuilder} in Python.) In this paper, we discuss the design of a \mintinline{c++}{TypedArrayBuilder}, which generates AwkwardForth programs from data types, but is still driven by \mintinline{c++}{ArrayBuilder}-like commands.

\section{Virtual machine implementation}

AwkwardForth is implemented in C++ as a virtual machine with byte-compiled instructions. It is not interactive, unlike most Forths, since it is intended to be programmed algorithmically. Even the \mintinline{c++}{TypedArrayBuilder} use-case would operate by ``wiring'' its fixed suite of commands to algorithmically generated words. Some \mintinline{c++}{TypedArrayBuilder} commands must change the state of its finite-state machine: for instance, when filling an array of doubly nested lists of integers, the second \mintinline{c++}{begin_list} puts it into a state that requires the next command to be \mintinline{c++}{integer} or \mintinline{c++}{end_list}; the first does not. And yet, each of these commands must return control-flow to that which calls them. To implement \mintinline{c++}{TypedArrayBuilder} with an AwkwardForth machine, the AwkwardForth machine must be able to stop and resume with its state intact (unlike most Forths).

An AwkwardForth machine has three control-flow states: ``not ready,'' ``paused,'' and ``done.'' In addition, its stack of integers and position markers in input and output buffers are also part of its state. There are 6 ways to control its execution:
\begin{itemize}
\item \mintinline{c++}{run(inputs)}: resets the machine from any state and runs the main code from the beginning. If it encounters a \mintinline{forth}{pause} word, it becomes ``paused,'' otherwise, the machine's state changes to ``done'' if successful or ``not ready'' if a runtime error is encountered.
\item \mintinline{c++}{begin(inputs)}: resets the machine from any state to ``paused'' before the first word.
\item \mintinline{c++}{resume()}: starts from ``paused'' and continues until reaching the end of the main code (``done''), or the end of a user-defined word, if started by a \mintinline{c++}{call(word)} (described below).
\item \mintinline{c++}{call(word)}: starting from ``paused'' or ``done,'' executes a user-defined word/subroutine.
\item \mintinline{c++}{step()}: starting from ``paused,'' executes one built-in word, stepping into user-defined words if necessary, resulting in ``paused'' or ``done'' (for debugging only).
\item \mintinline{c++}{reset()}: from any state, clears the stack, all variables, detaches the input buffers and deletes the output buffers, resulting in ``not ready.''
\end{itemize}

When an AwkwardForth machine is first constructed, it compiles its source code (text) into bytecode instructions (32-bit integers), so that so that they can be interpreted more quickly. (This is the same sense in which Python is ``compiled.'') Built-in words translate to 1--3 compiled instructions, the second and third being arguments that modify the first. User-defined words are separate sequences of instructions, called a ``dictionary'' in Forth. Control-flow structures, such as \mintinline{forth}{if} and \mintinline{forth}{loop}, are implemented as unnamed user-defined words so that their bodies are fixed-width ``calls'' into the dictionary, simplifying the logic of instruction pointer manipulation.

All errors are caught in the compilation phase except for 10 possible runtime errors: ``user halt,'' ``recursion depth exceeded,'' ``stack underflow,'' ``stack overflow,'' ``division by zero,'' ``read beyond,'' ``seek beyond,'' ``skip beyond,'' ``rewind beyond,'' and ``varint too big.'' The last 5 of these are specific to parsing input buffers.

All runtime execution is implemented within a single ``\mintinline{c++}{noexcept}'' C++ function.






\section{Acknowledgements}

This work was supported by the National Science Foundation under Cooperative Agreement OAC-1836650 (IRIS-HEP).

% BibTeX or Biber users please use (the style is already called in the class, ensure that the "woc.bst" style is in your local directory)
\bibliography{bibfile}

%% % Non-BibTeX users please use

%% \begin{thebibliography}{}

%% % and use \bibitem to create references.

%% \bibitem{RefJ}
%% \end{thebibliography}

\end{document}

% end of file template.tex
