%%%%%%%%%%%%%%%%%%%%%%% file template.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is a template file for Web of Conferences Journal
%
% Copy it to a new file with a new name and use it as the basis
% for your article
%
%%%%%%%%%%%%%%%%%%%%%%%%%% EDP Science %%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%\documentclass[option]{webofc}
%%% "twocolumn" for typesetting an article in two columns format (default one column)

\documentclass{webofc}
\usepackage[varg]{txfonts}   % Web of Conferences font
\usepackage{natbib}

%%% for the arXiv, be sure to include _minted-main/
% \usepackage[draft]{minted}
\usepackage{minted}

\begin{document}

\title{AwkwardForth: accelerating Uproot with an internal DSL}
% \subtitle{HERE}

\author{\firstname{Jim} \lastname{Pivarski}\inst{1}\fnsep\thanks{\email{pivarski@princeton.edu}} \and
        \firstname{Ianna} \lastname{Osborne}\inst{1}\fnsep\thanks{\email{ianna.osborne@cern.ch}} \and
        \firstname{Pratyush} \lastname{Das}\inst{2}\fnsep\thanks{\email{reikdas@gmail.com}} \and
        \firstname{David} \lastname{Lange}\inst{1}\fnsep\thanks{\email{david.lange@cern.ch}} \and
        \firstname{Peter} \lastname{Elmer}\inst{1}\fnsep\thanks{\email{peter.elmer@cern.ch}}}

\institute{Princeton University, Princeton, New Jersey, United States. \and Institute of Engineering and Management, Kolkata, West Bengal, India.}

\abstract{
  Insert your english abstract here.
}

\maketitle

\section{Motivation}

Despite being written in Python, Uproot~\cite{uproot} can read simple data types from ROOT~\cite{root} files as fast as any compiled code because these values are already contiguous in the raw bytes of the file. No computations are required to get a ROOT TBasket of numerical data from disk into memory, as an array, except to swap endianness if little-endian arrays are desired. Python's NumPy~\cite{numpy} library casts data from raw bytes as a metadata-only operation, and performs operations that scale as $\mathcal{O}(n)$, where $n$ is the length of the array, in precompiled code.

For more complex data types, however, the cost of computing in Python increases. Variable-length (``jagged'') arrays are still relatively quick, since the ROOT format separates the numerical content of these arrays from the integers that define the starting positions of each entry's array. This is nearly the format required by Awkward Array~\cite{awkward}, and only requires minor transformations, like subtracting the TBasket header from the byte offsets and dividing them by the number of bytes per entry. Objects with fixed-size headers and consisting of fixed-size fields, such as \mintinline{c++}{std::vector<TLorentzVector>}, can be extracted using NumPy tricks, though these tricks require more intermediate arrays, further slowing the transformation. Finally, general objects with nested, variable-length data, the simplest of which is \mintinline{c++}{std::vector<std::vector<float>>}, require custom loops over the data. In Python, this is hundreds of times slower than C++.

Previously, we quantified this slow-down~\cite{chep2019} using ROOT files containing \mintinline{c++}{float}, \mintinline{c++}{std::vector<float>}, and vectors of vectors up to three levels deep, reading them with the then-current Python codebase and with custom C++ code, which represents what is possible now that Awkward Array is implemented in C++. The read performance of \mintinline{c++}{float} data is identical for Python and C++, the C++ is several times faster for \mintinline{c++}{std::vector<float>}, and the gap widens to factors of hundreds for the doubly-nested and triply-nested cases. Leveraging Awkward Array's C++ layer to accelerate Uproot is a worthwhile goal.

However, unless we limit our attention to special cases like nested vectors of numbers, this deserialization code is not known at compile-time. The byte-for-byte layout of a complex data type is expressed as data, in the TStreamerInfo of a ROOT file, and is therefore discovered at runtime. Moreover, the specifics of ROOT deserialization should not be spread between two packages, Uproot and Awkward Array: Uproot should focus entirely on ROOT I/O as Awkward Array focuses on array manipulation. The problem is to satisfy three constraints:
\begin{enumerate}
\item Deserialization code must run as fast (or nearly as fast) as compiled code.
\item This code must be generated at runtime from TStreamerInfo.
\item All ``knowledge'' of ROOT I/O must be in Uproot, not Awkward Array.
\end{enumerate}

The first two constraints could be satisfied by just-in-time (JIT) compilation. This is, in fact, what ROOT's Cling compiler does. The third constraint could be satisfied by adding a C++ layer to Uproot. Both of these solutions, however, would significantly complicate the dependencies of Uproot or Awkward Array, and Uproot's portability is often cited as its best feature. The issue is not the disk space required to download a JIT compiler, but the likelihood of failure---complex software doesn't install as easily as it should in all environments.

This paper describes a different solution to the constraints listed above, which does not affect the portability of Uproot or Awkward Array. We introduce AwkwardForth, a domain-specific language (DSL) for deserializing arbitrary data into Awkward Arrays that is runtime-interpreted but nearly as fast as compiled code. Unlike DSLs intended for humans to read and write, this DSL is ``internal,'' only used to communicate between software packages. Uproot's task becomes one of expressing ROOT I/O logic in AwkwardForth and Awkward Array executes it, returning filled arrays.

\section{AwkwardForth}

AwkwardForth is a member of the Forth~\cite{forth} family of languages, which includes Postscript, another internal DSL. AwkwardForth adheres to a subset of the ANSI Forth Standard~\cite{forth-standard} and has extensions for interpreting input buffers and filling columns for Awkward Array.

Like all Forths, AwkwardForth is primarily concerned with stack manipulation. The runtime environment features a stack of integers and programs define ``words'' that manipulate the stack (as well as input and output buffers, in the case of AwkwardForth). Each word consumes and produces an arbitrary number of arguments and return values through this stack, and hence Forth words are more general than functions in a typical programming language. Whereas functional programming languages eliminate or minimize side-effects, Forth acts exclusively through side-effects. As such, it is more like an extensible assembly language.







\section{Acknowledgements}

This work was supported by the National Science Foundation under Cooperative Agreement OAC-1836650 (IRIS-HEP).

% BibTeX or Biber users please use (the style is already called in the class, ensure that the "woc.bst" style is in your local directory)
\bibliography{bibfile}

%% % Non-BibTeX users please use

%% \begin{thebibliography}{}

%% % and use \bibitem to create references.

%% \bibitem{RefJ}
%% \end{thebibliography}

\end{document}

% end of file template.tex
